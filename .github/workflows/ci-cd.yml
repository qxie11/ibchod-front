name: CI/CD Pipeline

on:
  push:
    branches: [main, stage, dev]
  pull_request:
    branches: [main]

env:
  AWS_REGION: eu-north-1
  ECR_REPOSITORY: iobchod-frontend
  ECS_CLUSTER: ecs-ec2-cluster
  CONTAINER_NAME: iphone-store-prod

jobs:
  ci:
    name: Continuous Integration
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: https://iobchod.shop/v1/api
          NEXT_PUBLIC_BASE_URL: https://iobchod.shop

  cd:
    name: Continuous Deployment
    runs-on: ubuntu-latest
    needs: ci
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/stage' || github.ref == 'refs/heads/dev'
    outputs:
      aws-credentials-present: ${{ steps.check-creds.outputs.credentials-present }}
      deployment-status: ${{ steps.deployment.outcome }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: set-vars
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            BRANCH="main"
            DEPLOY_TAG="latest"
            ENV="production"
            ECS_SERVICE="frontend-service-prod"
          elif [ "${{ github.ref }}" = "refs/heads/stage" ]; then
            BRANCH="stage"
            DEPLOY_TAG="stage"
            ENV="staging"
            ECS_SERVICE="frontend-service-stage"
          elif [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            BRANCH="dev"
            DEPLOY_TAG="dev"
            ENV="development"
            ECS_SERVICE="frontend-service-dev"
          fi
          
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "deploy-tag=$DEPLOY_TAG" >> $GITHUB_OUTPUT
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "ecs-service=$ECS_SERVICE" >> $GITHUB_OUTPUT
          
          echo "ğŸ—ï¸  Deployment Configuration:"
          echo "   Branch: $BRANCH"
          echo "   Deploy Tag: $DEPLOY_TAG"
          echo "   Environment: $ENV"
          echo "   ECS Service: $ECS_SERVICE"

      - name: Check AWS credentials
        id: check-creds
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "credentials-present=false" >> $GITHUB_OUTPUT
            echo "AWS_CREDENTIALS_PRESENT=false" >> $GITHUB_ENV
            echo "âš ï¸ AWS credentials missing. Skipping deployment."
          else
            echo "credentials-present=true" >> $GITHUB_OUTPUT
            echo "AWS_CREDENTIALS_PRESENT=true" >> $GITHUB_ENV
            echo "âœ… AWS credentials found."
          fi

      - name: Configure AWS credentials
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          FULL_SHA: ${{ github.sha }}
          DEPLOY_TAG: ${{ steps.set-vars.outputs.deploy-tag }}
        run: |
          if [ ! -f "Dockerfile" ]; then
            echo "âŒ Dockerfile not found in repository root"
            exit 1
          fi

          echo "ğŸ³ Building image for ${{ steps.set-vars.outputs.environment }} environment..."
          echo "ğŸ“¦ Creating tags:"
          echo "   1. Full SHA: $ECR_REGISTRY/$ECR_REPOSITORY:$FULL_SHA"
          echo "   2. Deploy Tag: $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_TAG"
          echo ""
          echo "ğŸ¯ ECS will use: $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_TAG"

          docker build \
            --build-arg NEXT_PUBLIC_API_URL=https://iobchod.shop/v1/api \
            --build-arg NEXT_PUBLIC_BASE_URL=https://iobchod.shop \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$FULL_SHA \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_TAG \
            .

          echo ""
          echo "â¬†ï¸  Pushing images to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$FULL_SHA
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_TAG

          echo ""
          echo "âœ… Images pushed successfully!"
          echo "   ğŸ¯ Deploy Image: $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_TAG"
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_TAG" >> $GITHUB_OUTPUT

      - name: Cleanup old SHA images
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        run: |
          echo "ğŸ§¹ Cleaning up old SHA-based images..."
          
          # Keep last 10 SHA images (full commit hashes)
          OLD_SHA_IMAGES=$(aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --query 'sort_by(imageDetails, &imagePushedAt)[:-10].imageIds[?imageTag && length(imageTag)==`40`]' \
            --output json | jq -r '.[].imageTag' 2>/dev/null || echo "")
          
          DELETED_COUNT=0
          
          if [ -n "$OLD_SHA_IMAGES" ] && [ "$OLD_SHA_IMAGES" != "" ]; then
            echo "   Deleting old SHA images (keeping latest 10):"
            for tag in $OLD_SHA_IMAGES; do
              echo "   - $tag"
              aws ecr batch-delete-image \
                --repository-name $ECR_REPOSITORY \
                --image-ids imageTag=$tag >/dev/null 2>&1 || true
              DELETED_COUNT=$((DELETED_COUNT + 1))
            done
          fi
          
          if [ $DELETED_COUNT -gt 0 ]; then
            echo "âœ… Deleted $DELETED_COUNT old SHA images"
          else
            echo "âœ… No old SHA images to clean"
          fi

      - name: Check ECS service status
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        id: check-service
        env:
          ECS_SERVICE: ${{ steps.set-vars.outputs.ecs-service }}
        run: |
          echo "Checking current ECS service status..."

          SERVICE_EXISTS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].serviceName' \
            --output text 2>/dev/null || echo "None")

          if [ "$SERVICE_EXISTS" = "None" ]; then
            echo "âŒ ECS service $ECS_SERVICE not found in cluster $ECS_CLUSTER"
            exit 1
          fi

          echo "ğŸ“‹ Service Configuration:"
          aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].{
              status:status,
              runningCount:runningCount,
              pendingCount:pendingCount,
              desiredCount:desiredCount,
              loadBalancers:loadBalancers,
              deploymentConfiguration:deploymentConfiguration
            }' \
            --output table

          echo ""
          echo "ğŸ” Load Balancer Setup:"
          LB_SETUP=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].loadBalancers' \
            --output json)

          if [ "$LB_SETUP" = "[]" ] || [ "$LB_SETUP" = "null" ]; then
            echo "âš ï¸  WARNING: No Load Balancer configured!"
            echo "   With hostPort:0 (dynamic ports), you need ALB/NLB for automatic traffic routing"
            echo "   Current setup may require manual port updates after container restart"
          else
            echo "âœ… Load Balancer configured:"
            echo "$LB_SETUP" | jq '.'
          fi

      - name: Get AWS Account ID
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        id: get-account-id
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account-id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "âœ… AWS Account ID: $ACCOUNT_ID"

      - name: Ensure CloudWatch Log Group exists
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        run: |
          LOG_GROUP_NAME="/ecs/iobchod-frontend"
          
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP_NAME" --query "logGroups[?logGroupName=='$LOG_GROUP_NAME']" --output text | grep -q "$LOG_GROUP_NAME"; then
            echo "âœ… Log group $LOG_GROUP_NAME already exists"
          else
            echo "ğŸ“ Creating log group $LOG_GROUP_NAME..."
            aws logs create-log-group --log-group-name "$LOG_GROUP_NAME"
            aws logs put-retention-policy --log-group-name "$LOG_GROUP_NAME" --retention-in-days 14
            echo "âœ… Log group $LOG_GROUP_NAME created"
          fi

      - name: Update ECS task definition with new image
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        id: task-def
        env:
          ECS_SERVICE: ${{ steps.set-vars.outputs.ecs-service }}
        run: |
          echo "ğŸ“ Updating task definition with branch-specific image..."
          echo "   Branch: ${{ steps.set-vars.outputs.branch }}"
          echo "   Deploy Tag: ${{ steps.set-vars.outputs.deploy-tag }}"
          echo "   Full Image: ${{ steps.build-image.outputs.image }}"
          echo "   ECS Service: $ECS_SERVICE"
          echo ""
          echo "Using clean branch tags:"
          echo "   âœ… main â†’ latest"
          echo "   âœ… stage â†’ stage"
          echo "   âœ… dev â†’ dev"
          echo ""
          echo "Task definition update forces ECS to pull fresh image"
          
          sed -i "s|IMAGE_URI|${{ steps.build-image.outputs.image }}|g" ecs-task-definition.json
          sed -i "s|ACCOUNT_ID|${{ steps.get-account-id.outputs.account-id }}|g" ecs-task-definition.json
          sed -i "s|\"family\": \"iobchod-frontend-task\"|\"family\": \"$ECS_SERVICE\"|g" ecs-task-definition.json
          
          echo ""
          echo "ğŸ“‹ Registering new task definition..."
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json file://ecs-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "task-definition-arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT
          echo "âœ… New task definition: $NEW_TASK_DEF"
          
          echo ""
          echo "ğŸ” Verifying task definition image:"
          aws ecs describe-task-definition \
            --task-definition $NEW_TASK_DEF \
            --query 'taskDefinition.containerDefinitions[0].{name:name,image:image}' \
            --output table

      - name: Update ECS service
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        id: deployment
        env:
          ECS_SERVICE: ${{ steps.set-vars.outputs.ecs-service }}
        run: |
          echo "ğŸš€ Updating ECS service with new task definition..."
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition ${{ steps.task-def.outputs.task-definition-arn }}
          
          echo "âœ… ECS service update initiated"

      - name: Wait for ECS service to be stable
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        env:
          ECS_SERVICE: ${{ steps.set-vars.outputs.ecs-service }}
        run: |
          echo "â³ Waiting for ECS service to be stable (timeout: 15 minutes)..."
          echo "ğŸ“‹ What happens during deployment:"
          echo "   1. ECS starts new task with updated image"
          echo "   2. Container starts and health checks begin"
          echo "   3. Health check grace period: 2 minutes"
          echo "   4. After successful health checks, old task is stopped"
          echo ""
          
          start_time=$(date +%s)
          timeout=900  # 15 minutes
          
          while true; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            if [ $elapsed -gt $timeout ]; then
              echo "âŒ Timeout after 15 minutes"
              break
            fi
            
            # Get service status
            SERVICE_INFO=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $ECS_SERVICE \
              --query 'services[0]')
            
            SERVICE_STATUS=$(echo "$SERVICE_INFO" | jq -r '.status')
            RUNNING_COUNT=$(echo "$SERVICE_INFO" | jq -r '.runningCount')
            PENDING_COUNT=$(echo "$SERVICE_INFO" | jq -r '.pendingCount')
            DESIRED_COUNT=$(echo "$SERVICE_INFO" | jq -r '.desiredCount')
            
            DEPLOYMENTS=$(echo "$SERVICE_INFO" | jq -r '.deployments')
            DEPLOYMENT_COUNT=$(echo "$DEPLOYMENTS" | jq 'length')
            
            echo "â±ï¸  ${elapsed}s | Service: $SERVICE_STATUS | Tasks: $RUNNING_COUNT/$DESIRED_COUNT (pending: $PENDING_COUNT) | Deployments: $DEPLOYMENT_COUNT"
            
            # Show deployment details
            echo "$DEPLOYMENTS" | jq -r '.[] | "   \(.status): \(.runningCount) running, \(.pendingCount) pending (\(.taskDefinition | split(":") | .[1]))"'
            
            # Check if stable
            if [ "$SERVICE_STATUS" = "ACTIVE" ] && \
               [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ] && \
               [ "$PENDING_COUNT" = "0" ] && \
               [ "$DEPLOYMENT_COUNT" = "1" ]; then
              echo "âœ… Service is stable!"
              exit 0
            fi
            
            # Get task details if there are issues
            if [ $elapsed -gt 300 ]; then  # After 5 minutes, start showing task details
              LATEST_TASKS=$(aws ecs list-tasks \
                --cluster $ECS_CLUSTER \
                --service-name $ECS_SERVICE \
                --max-items 3 \
                --query 'taskArns' \
                --output text)
              
              if [ -n "$LATEST_TASKS" ] && [ "$LATEST_TASKS" != "None" ]; then
                echo "ğŸ” Recent task status:"
                for task in $LATEST_TASKS; do
                  TASK_INFO=$(aws ecs describe-tasks \
                    --cluster $ECS_CLUSTER \
                    --tasks $task \
                    --query 'tasks[0]')
                  
                  TASK_STATUS=$(echo "$TASK_INFO" | jq -r '.lastStatus')
                  HEALTH_STATUS=$(echo "$TASK_INFO" | jq -r '.containers[0].healthStatus // "UNKNOWN"')
                  
                  echo "   $(basename $task): $TASK_STATUS (health: $HEALTH_STATUS)"
                  
                  # Show stopped reason if task failed
                  if [ "$TASK_STATUS" = "STOPPED" ]; then
                    STOPPED_REASON=$(echo "$TASK_INFO" | jq -r '.stoppedReason // "Unknown"')
                    echo "     Stopped reason: $STOPPED_REASON"
                    
                    # Show container exit details
                    echo "$TASK_INFO" | jq -r '.containers[0] | "     Container: \(.name) - exit code: \(.exitCode // "N/A"), reason: \(.reason // "N/A")"'
                  fi
                done
                echo ""
              fi
            fi
            
            sleep 30
          done
          
          # Final status check
          echo ""
          echo "ğŸ” Final diagnosis:"
          aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].{status:status,runningCount:runningCount,pendingCount:pendingCount,desiredCount:desiredCount,deployments:deployments[*].{status:status,taskDefinition:taskDefinition,runningCount:runningCount,pendingCount:pendingCount,createdAt:createdAt}}'
          
            exit 1

      - name: Get container logs for debugging
        if: env.AWS_CREDENTIALS_PRESENT == 'true' && failure()
        env:
          ECS_SERVICE: ${{ steps.set-vars.outputs.ecs-service }}
        run: |
          echo "ğŸ” Retrieving container logs for debugging..."
          
          # Get the latest tasks
          RECENT_TASKS=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --max-items 5 \
            --query 'taskArns' \
            --output text)
          
          if [ -n "$RECENT_TASKS" ] && [ "$RECENT_TASKS" != "None" ]; then
            for task in $RECENT_TASKS; do
              TASK_ID=$(basename $task)
              echo ""
              echo "ğŸ“‹ Logs for task: $TASK_ID"
              echo "=================================="
              
              # Try to get logs from CloudWatch
              LOG_STREAM="ecs/frontend/$TASK_ID"
              
              # Get logs from the last 10 minutes
              START_TIME=$(($(date +%s) * 1000 - 600000))
              
              echo "ğŸ” Checking CloudWatch logs: /ecs/iobchod-frontend/$LOG_STREAM"
              
              LOGS=$(aws logs get-log-events \
                --log-group-name "/ecs/iobchod-frontend" \
                --log-stream-name "$LOG_STREAM" \
                --start-time $START_TIME \
                --query 'events[*].message' \
                --output text 2>/dev/null || echo "No logs available")
              
              if [ "$LOGS" = "No logs available" ] || [ -z "$LOGS" ]; then
                echo "âš ï¸  No CloudWatch logs found for this task"
                
                # Check task status for more details
                TASK_DETAILS=$(aws ecs describe-tasks \
                  --cluster $ECS_CLUSTER \
                  --tasks $task \
                  --query 'tasks[0]')
                
                echo "Task details:"
                echo "$TASK_DETAILS" | jq -r '{
                  lastStatus: .lastStatus,
                  desiredStatus: .desiredStatus,
                  healthStatus: .containers[0].healthStatus,
                  exitCode: .containers[0].exitCode,
                  reason: .containers[0].reason,
                  stoppedReason: .stoppedReason
                }'
              else
                echo "$LOGS" | tail -50  # Show last 50 log lines
              fi
            done
          else
            echo "âš ï¸  No tasks found to retrieve logs from"
          fi

      - name: Health check diagnosis
        if: env.AWS_CREDENTIALS_PRESENT == 'true' && failure()
        env:
          ECS_SERVICE: ${{ steps.set-vars.outputs.ecs-service }}
        run: |
          echo ""
          echo "ğŸ¥ Health Check Diagnosis"
          echo "========================"
          echo "Expected health check: curl -f http://localhost:9002/"
          echo ""
          echo "Common issues:"
          echo "1. App not listening on port 9002"
          echo "2. App not responding to HTTP requests on /"
          echo "3. App taking longer than 2 minutes to start"
          echo "4. Insufficient CPU/memory resources"
          echo "5. Missing environment variables"
          echo "6. Build/dependency issues"
          echo ""
          echo "Checking if health check endpoint is accessible..."
          
          # Get one running task to test
          RUNNING_TASK=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --desired-status RUNNING \
            --max-items 1 \
            --query 'taskArns[0]' \
            --output text)
          
          if [ -n "$RUNNING_TASK" ] && [ "$RUNNING_TASK" != "None" ]; then
            echo "Testing health check on running task..."
            
            # Get task details
            TASK_DETAILS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $RUNNING_TASK \
              --query 'tasks[0]')
            
            # Try to get public IP or private IP
            ENI_ID=$(echo "$TASK_DETAILS" | jq -r '.attachments[0].details[] | select(.name=="networkInterfaceId") | .value // empty')
            
            if [ -n "$ENI_ID" ]; then
              PRIVATE_IP=$(aws ec2 describe-network-interfaces \
                --network-interface-ids $ENI_ID \
                --query 'NetworkInterfaces[0].PrivateIpAddress' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$PRIVATE_IP" ]; then
                echo "Task private IP: $PRIVATE_IP"
                echo "Health check URL: http://$PRIVATE_IP:9002/"
              fi
            fi
          fi

      - name: Verify deployment and check ports
        if: env.AWS_CREDENTIALS_PRESENT == 'true'
        env:
          ECS_SERVICE: ${{ steps.set-vars.outputs.ecs-service }}
        run: |
          echo "ğŸ” Verifying deployment and port configuration..."
          
          aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].{status:status,runningCount:runningCount,pendingCount:pendingCount,desiredCount:desiredCount}'

          echo ""
          echo "ğŸ”Œ Current Running Tasks and Ports:"
          
          # Get running tasks
          RUNNING_TASKS=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --desired-status RUNNING \
            --query 'taskArns' \
            --output text)

          if [ -n "$RUNNING_TASKS" ] && [ "$RUNNING_TASKS" != "None" ]; then
            for task in $RUNNING_TASKS; do
              TASK_ID=$(basename $task)
              echo "ğŸ“‹ Task: $TASK_ID"
              
              # Get task details including network bindings
              TASK_DETAILS=$(aws ecs describe-tasks \
                --cluster $ECS_CLUSTER \
                --tasks $task \
                --query 'tasks[0]')
              
              # Show port mappings
              NETWORK_BINDINGS=$(echo "$TASK_DETAILS" | jq -r '.containers[0].networkBindings[]? | "   Container Port \(.containerPort) â†’ Host Port \(.hostPort) (Protocol: \(.protocol))"')
              
              if [ -n "$NETWORK_BINDINGS" ]; then
                echo "$NETWORK_BINDINGS"
              else
                echo "   âš ï¸  No network bindings found"
              fi
              
              # Get container instance info for public IP
              CONTAINER_INSTANCE_ARN=$(echo "$TASK_DETAILS" | jq -r '.containerInstanceArn')
              
              if [ "$CONTAINER_INSTANCE_ARN" != "null" ]; then
                INSTANCE_ID=$(aws ecs describe-container-instances \
                  --cluster $ECS_CLUSTER \
                  --container-instances $CONTAINER_INSTANCE_ARN \
                  --query 'containerInstances[0].ec2InstanceId' \
                  --output text)
                
                if [ "$INSTANCE_ID" != "None" ]; then
                  PUBLIC_IP=$(aws ec2 describe-instances \
                    --instance-ids $INSTANCE_ID \
                    --query 'Reservations[0].Instances[0].PublicIpAddress' \
                    --output text)
                  
                  PRIVATE_IP=$(aws ec2 describe-instances \
                    --instance-ids $INSTANCE_ID \
                    --query 'Reservations[0].Instances[0].PrivateIpAddress' \
                    --output text)
                  
                  HOST_PORT=$(echo "$TASK_DETAILS" | jq -r '.containers[0].networkBindings[0].hostPort // empty')
                  
                  if [ -n "$HOST_PORT" ] && [ "$HOST_PORT" != "null" ]; then
                    echo "   ğŸŒ Access URLs:"
                    if [ "$PUBLIC_IP" != "None" ] && [ -n "$PUBLIC_IP" ]; then
                      echo "   Public:  http://$PUBLIC_IP:$HOST_PORT"
                    fi
                    if [ "$PRIVATE_IP" != "None" ] && [ -n "$PRIVATE_IP" ]; then
                      echo "   Private: http://$PRIVATE_IP:$HOST_PORT"
                    fi
                  fi
                fi
              fi
              echo ""
            done
          else
            echo "âš ï¸  No running tasks found"
          fi

          echo "âœ… Deployment completed successfully!"

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [ci, cd]
    if: always() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/stage' || github.ref == 'refs/heads/dev')

    steps:
      - name: Set notification variables
        id: notify-vars
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "url=https://iobchod.shop" >> $GITHUB_OUTPUT
            echo "tag=latest" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/stage" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "url=https://stage.iobchod.shop" >> $GITHUB_OUTPUT
            echo "tag=stage" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "url=https://dev.iobchod.shop" >> $GITHUB_OUTPUT
            echo "tag=dev" >> $GITHUB_OUTPUT
          fi

      - name: Notify Success
        if: needs.cd.result == 'success' && needs.cd.outputs.aws-credentials-present == 'true'
        run: |
          echo "ğŸ‰ Deployment to ${{ steps.notify-vars.outputs.environment }} completed successfully!"
          echo "ğŸ·ï¸ Image tag: ${{ steps.notify-vars.outputs.tag }}"
          echo "ğŸŒ Application is available at: ${{ steps.notify-vars.outputs.url }}"

      - name: Notify CD Skipped
        if: needs.cd.outputs.aws-credentials-present == 'false'
        run: |
          echo "âš ï¸ CI completed successfully, but CD was skipped."
          echo "Configure AWS credentials to enable automatic deployment."
          echo "ğŸ“š See README-CI-CD.md for setup instructions."

      - name: Notify Failure
        if: needs.cd.result == 'failure'
        run: |
          echo "âŒ Deployment to ${{ steps.notify-vars.outputs.environment }} failed!"
          echo "Please check the logs and fix the issues."
